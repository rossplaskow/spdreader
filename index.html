<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>RSVP Reader</title>
  <style>
    :root{
      --bg:#000;
      --text:#fff;
      --muted:rgba(255,255,255,0.65);
      --border:rgba(255,255,255,0.16);
      --accent:#ff3b3b;
      --btnbg:rgba(255,255,255,0.08);
      --btnbg2:rgba(255,255,255,0.12);
    }

    *{ box-sizing:border-box; }
    html,body{
      height:100%;
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial;
      overscroll-behaviour:none;
      -webkit-tap-highlight-color: transparent;
    }

    .app{
      height:100%;
      display:flex;
      flex-direction:column;

      /* extra padding left/right + extra bottom breathing room */
      padding:
        env(safe-area-inset-top)
        42px
        calc(env(safe-area-inset-bottom) + 40px)
        42px;
    }

    .centre{
      flex:1;
      display:flex;
      align-items:center;
      justify-content:flex-start;
      min-height:0;
    }

    /* RSVP line */
    .rsvp{
      width:100%;
      max-width: 900px;

      display:flex;
      align-items:baseline;
      justify-content:flex-start;

      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;

      /* Base size, JS may reduce it on long words */
      font-size: clamp(42px, 10vw, 72px);

      line-height:1.1;
      letter-spacing:0.4px;
      white-space:nowrap;

      /* breathing room inside word area */
      padding: 10px 10px;

      /* JS will set translateX each render */
      transform: translateX(0px);
      will-change: transform;
    }

    .left{
      text-align:left;
      opacity:0.95;
      overflow:hidden;
    }
    .focus{
      color:var(--accent);
      font-weight:900;
      padding:0;

      /* important: makes width/centre stable for getBoundingClientRect */
      display:inline-block;
    }
    .right{
      text-align:left;
      opacity:0.95;
      overflow:hidden;
    }

    .bottom{
      padding-top: 10px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    .row{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:10px;
    }

    button{
      appearance:none;
      border:1px solid var(--border);
      background:var(--btnbg);
      color:var(--text);
      border-radius:14px;
      padding:14px 10px;
      font-size:16px;
      font-weight:700;
      cursor:pointer;
      user-select:none;
    }
    button:active{
      background:var(--btnbg2);
      transform: translateY(1px);
    }

    .speedRow{
      display:grid;
      grid-template-columns: 1fr 1.2fr 1fr;
      gap:10px;
      align-items:center;
    }

    .speedBox{
      text-align:center;
      color:var(--muted);
      font-weight:700;
      font-size:15px;
      border:1px solid var(--border);
      border-radius:14px;
      padding:14px 10px;
      background: rgba(255,255,255,0.04);
    }

    .toast{
      position:fixed;
      left:50%;
      bottom: calc(env(safe-area-inset-bottom) + 110px);
      transform: translateX(-50%);
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255, 59, 59, 0.35);
      background: rgba(255, 59, 59, 0.12);
      color: rgba(255,255,255,0.95);
      font-size:14px;
      max-width: 92vw;
      display:none;
      text-align:center;
      white-space: pre-line;
    }

    .tiny{
      position:fixed;
      top: calc(env(safe-area-inset-top) + 10px);
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255,255,255,0.30);
      font-size: 12px;
      letter-spacing: 0.3px;
      user-select:none;
      pointer-events:none;
      white-space:nowrap;
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="tiny" id="progressTiny"></div>

    <div class="centre">
      <div class="rsvp" id="rsvpLine" aria-live="polite">
        <span class="left" id="leftPart"></span>
        <span class="focus" id="focusChar">•</span>
        <span class="right" id="rightPart"></span>
      </div>
    </div>

    <div class="bottom">
      <div class="row">
        <button id="backBtn">Back 10</button>
        <button id="playPauseBtn">Play</button>
        <button id="fwdBtn">Forward 10</button>
      </div>

      <div class="speedRow">
        <button id="slowerBtn">-10</button>
        <div class="speedBox" id="speedBox">350 WPM</div>
        <button id="fasterBtn">+10</button>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <script>
    (function () {
      "use strict";

      // -------- settings --------
      const DEFAULT_FILE = "reader.txt";
      const DEFAULT_WPM = 250;

      // pauses
      const SENTENCE_HOLD_MS = 500;   // . ! ?
      const COMMA_HOLD_MS = 350;      // ,
      const COLON_HOLD_MS = 350;      // :
      const SEMICOLON_HOLD_MS = 300;  // ;
      const DASH_HOLD_MS = 300;       // pseudo-  or  word–  etc

      // newline pauses (headings, paragraph breaks)
      const NEWLINE_HOLD_MS = 450;

      const JUMP_WORDS = 10;

      // Font fitting
      const MIN_FONT_PX = 18;
      const FIT_PADDING_PX = 22;

      // Focus letter position in word
      // 0.00 = first letter
      // 0.10 = 10% into the word
      // 0.40 = classic-ish RSVP position
      const FOCUS_FRACTION = 0.2;

      // This is your "nudge" after perfect centring
      // negative = left, positive = right
      const FOCUS_CENTER_OFFSET_PX = -100;

      // -------- localStorage keys --------
      const LS_IDX  = "rsvp_idx";
      const LS_WPM  = "rsvp_wpm";
      const LS_FILE = "rsvp_file";

      // -------- elements --------
      const rsvpLine = document.getElementById("rsvpLine");
      const leftPartEl = document.getElementById("leftPart");
      const focusCharEl = document.getElementById("focusChar");
      const rightPartEl = document.getElementById("rightPart");

      const backBtn = document.getElementById("backBtn");
      const playPauseBtn = document.getElementById("playPauseBtn");
      const fwdBtn = document.getElementById("fwdBtn");

      const slowerBtn = document.getElementById("slowerBtn");
      const fasterBtn = document.getElementById("fasterBtn");
      const speedBox = document.getElementById("speedBox");

      const toastEl = document.getElementById("toast");
      const progressTiny = document.getElementById("progressTiny");

      // -------- state --------
      let words = [];
      let idx = 0;
      let wpm = DEFAULT_WPM;
      let playing = false;
      let timer = null;

      // For measuring text
      const measureCanvas = document.createElement("canvas");
      const measureCtx = measureCanvas.getContext("2d");

      // For stable centring (avoid oscillation)
      let centreRAF = null;

      // IMPORTANT: store the "real default font size" once, so it never drifts smaller
      let DEFAULT_FONT_PX = null;

      function clamp(n, lo, hi) {
        return Math.max(lo, Math.min(hi, n));
      }

      function normaliseWpm(n) {
        const x = Number(n);
        if (!Number.isFinite(x)) return DEFAULT_WPM;
        return clamp(Math.round(x), 50, 2000);
      }

      function msPerWord() {
        return Math.round(60000 / wpm);
      }

      // Allow lots of trailing "closers" after punctuation
      const TRAIL_CLOSERS = `["')\\]\\}”’»]`;

      function stripNewlineMarkers(word) {
        return (word || "").replace(/\n+$/g, "");
      }

      function countTrailingNewlines(word) {
        const m = (word || "").match(/\n+$/);
        return m ? m[0].length : 0;
      }

      // ✅ sentence end:
      //  - normal: hello.  hello!”  hello.)
      //  - ALSO: hello.6   hello.”6 (reference marker after full stop)
      function isSentenceEnd(word) {
        const re = new RegExp(
          `(?:[!?](?:${TRAIL_CLOSERS})*$)|` +                 // ! or ?
          `(?:\\.(?:${TRAIL_CLOSERS})*$)|` +                  // normal full stop end
          `(?:\\.(?:${TRAIL_CLOSERS})*\\d+(?:${TRAIL_CLOSERS})*$)` // full stop then digits at end
        );
        return re.test(word);
      }

      function isCommaEnd(word) {
        const re = new RegExp(`,(?:${TRAIL_CLOSERS})*$`);
        return re.test(word);
      }

      function isColonEnd(word) {
        const re = new RegExp(`:(?:${TRAIL_CLOSERS})*$`);
        return re.test(word);
      }

      function isSemicolonEnd(word) {
        const re = new RegExp(`;(?:${TRAIL_CLOSERS})*$`);
        return re.test(word);
      }

      // Includes common hyphen/dash characters
      function isDashEnd(word) {
        const re = new RegExp(`[-\\u2010\\u2011\\u2012\\u2013\\u2014\\u2212\\uFE63\\uFF0D](?:${TRAIL_CLOSERS})*$`);
        return re.test(word);
      }

      function extraHoldMs(wordRaw) {
        const nlCount = countTrailingNewlines(wordRaw);
        const newlineHold = nlCount * NEWLINE_HOLD_MS;

        const word = stripNewlineMarkers(wordRaw);

        let punct = 0;
        if (isSentenceEnd(word)) punct = SENTENCE_HOLD_MS;
        else if (isColonEnd(word)) punct = COLON_HOLD_MS;
        else if (isSemicolonEnd(word)) punct = SEMICOLON_HOLD_MS;
        else if (isCommaEnd(word)) punct = COMMA_HOLD_MS;
        else if (isDashEnd(word)) punct = DASH_HOLD_MS;

        return newlineHold + punct;
      }

      function computeFocusIndex(word) {
        const len = word.length;
        if (len <= 1) return 0;

        const raw = Math.round(len * FOCUS_FRACTION);
        return clamp(raw, 0, len - 1);
      }

      function splitForDisplay(wordRaw) {
        const word = stripNewlineMarkers(wordRaw);
        const i = computeFocusIndex(word);
        return {
          left: word.slice(0, i),
          focus: word.slice(i, i + 1),
          right: word.slice(i + 1)
        };
      }

      function stopTimer() {
        if (timer !== null) {
          clearTimeout(timer);
          timer = null;
        }
      }

      function setSpeedBox() {
        speedBox.textContent = `${wpm} WPM`;
      }

      function setPlayButton() {
        playPauseBtn.textContent = playing ? "Pause" : "Play";
      }

      function saveOnPause() {
        localStorage.setItem(LS_IDX, String(idx));
        localStorage.setItem(LS_WPM, String(wpm));
      }

      function saveFileName(name) {
        localStorage.setItem(LS_FILE, name);
      }

      function setFontPx(px) {
        rsvpLine.style.fontSize = `${px}px`;
      }

      function measureWidth(text, fontPx) {
        const cs = getComputedStyle(rsvpLine);
        measureCtx.font = `${cs.fontWeight} ${fontPx}px ${cs.fontFamily}`;
        return measureCtx.measureText(text).width;
      }

      // ✅ shrink-to-fit, but ALWAYS reset to true default first,
      // so font does NOT drift smaller over time
      function fitWordToScreen(parts) {
        if (DEFAULT_FONT_PX === null) {
          const cs = getComputedStyle(rsvpLine);
          const px = parseFloat(cs.fontSize);
          DEFAULT_FONT_PX = Number.isFinite(px) ? px : 48;
        }

        const basePx = DEFAULT_FONT_PX;

        // Always reset to default size for each word
        setFontPx(basePx);

        const containerWidth = rsvpLine.clientWidth;
        if (!containerWidth) return;

        const fullText = (parts.left || "") + (parts.focus || "") + (parts.right || "");
        const fullW = measureWidth(fullText, basePx);

        const available = Math.max(0, containerWidth - FIT_PADDING_PX);

        // If it fits, keep default size (important)
        if (fullW <= available || fullW === 0) {
          setFontPx(basePx);
          return;
        }

        // Otherwise shrink just for this word
        const scale = available / fullW;
        const newPx = Math.floor(basePx * scale);
        setFontPx(Math.max(MIN_FONT_PX, newPx));
      }

      // ---- centre the highlighted letter consistently ----
      function centreFocusLetterNow() {
        const centreEl = rsvpLine.parentElement; // .centre
        if (!centreEl) return;

        // ALWAYS measure from a known state (no previous translateX)
        rsvpLine.style.transform = "translateX(0px)";

        // Force layout so measurements are correct this frame
        rsvpLine.getBoundingClientRect();

        const centreRect = centreEl.getBoundingClientRect();
        const focusRect = focusCharEl.getBoundingClientRect();

        if (!focusRect.width || !centreRect.width) return;

        const desiredX = centreRect.left + (centreRect.width / 2) + FOCUS_CENTER_OFFSET_PX;
        const currentX = focusRect.left + (focusRect.width / 2);

        const delta = desiredX - currentX;
        rsvpLine.style.transform = `translateX(${delta}px)`;
      }

      function scheduleCentreFocus() {
        if (centreRAF !== null) cancelAnimationFrame(centreRAF);
        centreRAF = requestAnimationFrame(() => {
          centreRAF = null;
          centreFocusLetterNow();
        });
      }

      function formatProgress() {
        if (!words.length) return "";

        const total = words.length;
        const current = idx + 1;
        const pct = (current / total) * 100;

        return `${current} / ${total} (${pct.toFixed(1)}%)`;
      }

      function render() {
        if (!words.length) {
          leftPartEl.textContent = "";
          focusCharEl.textContent = "•";
          rightPartEl.textContent = "";
          progressTiny.textContent = "";
          rsvpLine.style.transform = "translateX(0px)";
          return;
        }

        idx = clamp(idx, 0, words.length - 1);
        const w = words[idx];
        const parts = splitForDisplay(w);

        leftPartEl.textContent = parts.left;
        focusCharEl.textContent = parts.focus || "";
        rightPartEl.textContent = parts.right;

        progressTiny.textContent = formatProgress();

        fitWordToScreen(parts);

        // Centre after DOM updates (prevents oscillation / alternating alignment)
        scheduleCentreFocus();
      }

      function scheduleNext() {
        stopTimer();
        if (!playing || !words.length) return;

        const base = msPerWord();
        const extra = extraHoldMs(words[idx] || "");
        const delay = base + extra;

        timer = setTimeout(() => {
          if (!playing) return;

          idx += 1;
          if (idx >= words.length) {
            idx = words.length - 1;
            render();
            pause();
            return;
          }

          render();
          scheduleNext();
        }, delay);
      }

      function play() {
        if (!words.length) return;
        playing = true;
        setPlayButton();
        scheduleNext();
      }

      function pause() {
        if (!playing) return;
        playing = false;
        stopTimer();
        setPlayButton();
        saveOnPause();
      }

      function togglePlayPause() {
        if (playing) pause();
        else play();
      }

      function jump(delta) {
        if (!words.length) return;
        idx = clamp(idx + delta, 0, words.length - 1);
        render();
        if (playing) scheduleNext();
      }

      function setWpm(newWpm) {
        wpm = normaliseWpm(newWpm);
        setSpeedBox();
        if (playing) scheduleNext();
      }

      function showToast(msg) {
        toastEl.textContent = msg;
        toastEl.style.display = "block";
        clearTimeout(showToast._t);
        showToast._t = setTimeout(() => {
          toastEl.style.display = "none";
        }, 2500);
      }

      // ---- dash splitting (attach dashes to LEFT word) ----
      const DASH_CLASS = "\\-\\u2010\\u2011\\u2012\\u2013\\u2014\\u2212\\uFE63\\uFF0D";
      const DASH_SPLIT_RE = new RegExp(`([${DASH_CLASS}])`, "g");
      const DASH_INSIDE_WORD_RE = new RegExp(`[^\\s${DASH_CLASS}][${DASH_CLASS}][^\\s${DASH_CLASS}]`);
      const DASH_ONLY_RE = new RegExp(`^[${DASH_CLASS}]$`);

      function stripTrailingPunct(token) {
        const m = token.match(/^(.*?)([.,!?;:]+["')\]\}”’»]*)$/);
        if (!m) return { base: token, trail: "" };
        return { base: m[1], trail: m[2] };
      }

      function shouldSplitDashes(base) {
        return DASH_INSIDE_WORD_RE.test(base);
      }

      function expandDashToken(token) {
        const { base, trail } = stripTrailingPunct(token);

        if (!shouldSplitDashes(base)) return [token];

        const rawParts = base.split(DASH_SPLIT_RE).filter(Boolean);
        if (!rawParts.length) return [token];

        const merged = [];
        for (const part of rawParts) {
          if (DASH_ONLY_RE.test(part)) {
            if (merged.length > 0) {
              merged[merged.length - 1] = merged[merged.length - 1] + part;
            } else {
              merged.push(part);
            }
          } else {
            merged.push(part);
          }
        }

        if (trail && merged.length) {
          merged[merged.length - 1] = merged[merged.length - 1] + trail;
        }

        return merged;
      }

      function parseTextToWords(text) {
        const cleaned = (text || "")
          .replace(/\uFEFF/g, "")
          .replace(/\r\n/g, "\n")
          .replace(/\r/g, "\n");

        const lines = cleaned.split("\n");
        const expanded = [];

        for (let li = 0; li < lines.length; li++) {
          const lineRaw = lines[li];
          const line = lineRaw.trim();

          if (line.length > 0) {
            const rawWords = line
              .split(/\s+/g)
              .map(s => s.trim())
              .filter(Boolean);

            for (const tok of rawWords) {
              const pieces = expandDashToken(tok);
              for (const p of pieces) expanded.push(p);
            }

            if (li < lines.length - 1 && expanded.length) {
              expanded[expanded.length - 1] = expanded[expanded.length - 1] + "\n";
            }
          } else {
            if (li < lines.length - 1 && expanded.length) {
              expanded[expanded.length - 1] = expanded[expanded.length - 1] + "\n";
            }
          }
        }

        return expanded;
      }

      async function loadTextFile(fileName) {
        const clean = (fileName || "").trim() || DEFAULT_FILE;
        saveFileName(clean);

        try {
          const res = await fetch(clean, { cache: "no-store" });
          if (!res.ok) throw new Error(`Could not load ${clean} (HTTP ${res.status})`);

          const txt = await res.text();
          const parsed = parseTextToWords(txt);
          if (!parsed.length) throw new Error(`${clean} loaded but has no words`);

          words = parsed;

          const savedIdx = Number(localStorage.getItem(LS_IDX) || "0");
          idx = Number.isFinite(savedIdx) ? clamp(savedIdx, 0, words.length - 1) : 0;

          render();
          playing = false;
          stopTimer();
          setPlayButton();
        } catch (e) {
          words = [];
          idx = 0;
          render();
          playing = false;
          stopTimer();
          setPlayButton();

          showToast(
            "Could not load reader.txt.\n" +
            "If you opened this file directly, run a tiny local server.\n" +
            "Example: python3 -m http.server"
          );
        }
      }

      // -------- buttons --------
      backBtn.addEventListener("click", () => jump(-JUMP_WORDS));
      fwdBtn.addEventListener("click", () => jump(JUMP_WORDS));
      playPauseBtn.addEventListener("click", () => togglePlayPause());

      slowerBtn.addEventListener("click", () => setWpm(wpm - 10));
      fasterBtn.addEventListener("click", () => setWpm(wpm + 10));

      document.querySelector(".centre").addEventListener("click", () => togglePlayPause());

      document.addEventListener("visibilitychange", () => {
        if (document.hidden) pause();
      });
      window.addEventListener("beforeunload", () => pause());

      window.addEventListener("resize", () => {
        render();
      });

      // -------- boot --------
      (function boot() {
        const savedWpm = localStorage.getItem(LS_WPM);
        wpm = normaliseWpm(savedWpm !== null ? savedWpm : DEFAULT_WPM);
        setSpeedBox();
        setPlayButton();
        render();

        // Capture true default font size once at startup (prevents drift)
        const cs = getComputedStyle(rsvpLine);
        const px = parseFloat(cs.fontSize);
        DEFAULT_FONT_PX = Number.isFinite(px) ? px : 48;

        const savedFile = localStorage.getItem(LS_FILE) || DEFAULT_FILE;
        loadTextFile(savedFile);
      })();

    })();
  </script>
</body>
</html>
